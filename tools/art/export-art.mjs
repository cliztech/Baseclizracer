import { spawnSync } from 'node:child_process';
import { existsSync } from 'node:fs';
import { mkdir, readFile, readdir, writeFile } from 'node:fs/promises';
import os from 'node:os';
import path from 'node:path';
import { fileURLToPath } from 'node:url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const projectRoot = path.resolve(__dirname, '..', '..');

const sheets = [
  {
    name: 'sprites',
    sourceDir: path.join(projectRoot, 'images', 'sprites'),
    sheetPath: path.join(projectRoot, 'images', 'sprites.png'),
    scriptPath: path.join(projectRoot, 'images', 'sprites.js'),
    variable: 'SPRITES',
    type: 'texturepacker'
  },
  {
    name: 'background',
    sourceDir: path.join(projectRoot, 'images', 'background'),
    sheetPath: path.join(projectRoot, 'images', 'background.png'),
    scriptPath: path.join(projectRoot, 'images', 'background.js'),
    variable: 'BACKGROUND',
    include: ['hills.png', 'sky.png', 'trees.png'],
    type: 'texturepacker'
  }
];

function findExporter(preference = process.env.ART_EXPORTER) {
  const candidates = [];
  const prefer = preference && preference.toLowerCase();

  if (!prefer || prefer === 'texturepacker') {
    candidates.push({
      type: 'texturepacker',
      names: [process.env.TEXTURE_PACKER_BIN, 'TexturePacker', 'texturepacker']
    });
  }

  if (!prefer || prefer === 'aseprite') {
    candidates.push({
      type: 'aseprite',
      names: [process.env.ASEPRITE_BIN, 'aseprite']
    });
  }

  for (const candidate of candidates) {
    for (const name of candidate.names.filter(Boolean)) {
      const result = spawnSync(name, ['--version'], { stdio: 'ignore' });
      if (result.status === 0) {
        return { type: candidate.type, bin: name };
      }
    }
  }

  throw new Error(
    'No art exporter found. Install TexturePacker or Aseprite CLI, or set ART_EXPORTER.'
  );
}

async function collectPngs(sourceDir, include) {
  const entries = await readdir(sourceDir, { withFileTypes: true });
  const filtered = entries
    .filter(
      (entry) =>
        entry.isFile() && path.extname(entry.name).toLowerCase() === '.png'
    )
    .filter((entry) => !include || include.includes(entry.name))
    .map((entry) => path.join(sourceDir, entry.name));

  if (!filtered.length) {
    throw new Error(`No PNG sprites found in ${sourceDir}`);
  }

  return filtered;
}

function normalizeKey(filename) {
  return filename
    .replace(path.extname(filename), '')
    .replace(/[^a-zA-Z0-9]+/g, '_')
    .toUpperCase();
}

function readRect(frame) {
  const rect = frame.frame || frame;

  const x = rect.x;
  const y = rect.y;
  const w = rect.w ?? rect.width;
  const h = rect.h ?? rect.height;

  if ([x, y, w, h].some((value) => typeof value !== 'number')) {
    throw new Error('Frame metadata is missing x, y, w, or h values.');
  }

  return { x, y, w, h };
}

async function writeMetadataJs(jsonPath, scriptPath, variable) {
  const parsed = JSON.parse(await readFile(jsonPath, 'utf8'));
  const frames = Array.isArray(parsed.frames)
    ? parsed.frames.map((frame) => ({
        filename: frame.filename || frame.name,
        frame
      }))
    : Object.entries(parsed.frames || {}).map(([filename, frame]) => ({
        filename,
        frame
      }));

  if (!frames.length) {
    throw new Error('No frames found in exporter metadata.');
  }

  const metadata = {};
  frames.forEach(({ filename, frame }) => {
    const key = normalizeKey(filename || 'frame');
    metadata[key] = readRect(frame);
  });

  const payload = [
    '// @generated by npm run build:art',
    '// Sprite sheet metadata generated for tooling and kept global for legacy consumers.',
    `var ${variable} = ${JSON.stringify(metadata, null, 2)};`,
    ''
  ].join('\n');

  await mkdir(path.dirname(scriptPath), { recursive: true });
  await writeFile(scriptPath, payload, 'utf8');
}

async function runTexturePacker(exporter, task) {
  const files = await collectPngs(task.sourceDir, task.include);
  const metadataPath = path.join(
    os.tmpdir(),
    `${task.name}-metadata-${Date.now()}-${process.pid}.json`
  );
  const args = [
    '--data',
    metadataPath,
    '--sheet',
    task.sheetPath,
    '--format',
    'json',
    '--disable-rotation',
    '--trim-mode',
    'None',
    '--border-padding',
    '5',
    '--shape-padding',
    '5',
    ...files
  ];

  const { status } = spawnSync(exporter.bin, args, { stdio: 'inherit' });

  if (status !== 0) {
    throw new Error(`TexturePacker failed while exporting ${task.name}`);
  }

  await writeMetadataJs(metadataPath, task.scriptPath, task.variable);
}

async function main() {
  const exporter = findExporter();
  for (const task of sheets) {
    if (exporter.type !== task.type) {
      throw new Error(
        `Configured exporter ${exporter.type} cannot run ${task.type} task for ${task.name}`
      );
    }

    if (!existsSync(task.sourceDir)) {
      throw new Error(`Source directory missing: ${task.sourceDir}`);
    }

    await mkdir(path.dirname(task.sheetPath), { recursive: true });

    if (exporter.type === 'texturepacker') {
      console.log(`Exporting ${task.name} with TexturePacker...`);
      await runTexturePacker(exporter, task);
      continue;
    }

    throw new Error(`Unsupported exporter type: ${exporter.type}`);
  }

  console.log('Art export complete.');
}

main().catch((error) => {
  console.error(error.message);
  process.exit(1);
});
